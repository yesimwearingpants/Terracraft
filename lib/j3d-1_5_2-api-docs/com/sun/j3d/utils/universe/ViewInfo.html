<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_11) on Sat Jun 28 09:43:37 PDT 2008 -->
<TITLE>
ViewInfo (3D 1.5.2)
</TITLE>

<META NAME="keywords" CONTENT="com.sun.j3d.utils.universe.ViewInfo class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ViewInfo (3D 1.5.2)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../com/sun/j3d/utils/universe/ViewerAvatar.html" title="class in com.sun.j3d.utils.universe"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../com/sun/j3d/utils/universe/ViewingPlatform.html" title="class in com.sun.j3d.utils.universe"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?com/sun/j3d/utils/universe/ViewInfo.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ViewInfo.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.sun.j3d.utils.universe</FONT>
<BR>
Class ViewInfo</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>com.sun.j3d.utils.universe.ViewInfo</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>ViewInfo</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Provides methods to extract synchronized transform information from a View.
 These transforms are derived from application scene graph information, as
 opposed to similar core Java 3D methods that derive transforms from
 internally maintained data.    This allows updates to the scene graph to be
 synchronized with the current view platform position.<p>

 The architecture of the Java 3D 1.3 sample implementation introduces a
 frame latency between updates to the application scene graph structure and
 their effects on internal Java 3D state. <code>getImagePlateToVworld</code>
 and other methods in the core Java 3D classes use a transform from view
 platform coordinates to virtual world coordinates that can be out of date
 with respect to the state of the view platform as set by the application.
 When an application uses the transforms returned by those methods to update
 view dependent parts of the scene graph, those updates might not be
 synchronized with what the viewer actually sees.<p>

 The methods in this class work around this problem at the expense of
 querying the application state of the scene graph to get the current
 transform from view platform to virtual world coordinates.  This can
 involve a potential performance degradation, however, since the application
 scene graph state is not designed for high performance queries.  The view
 platform must also have <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability
 set, which potentially inhibits internal scene graph optimization.<p>

 On the other hand, application behaviors that create the view platform
 transformation directly will have access to it without the need to query it
 from the scene graph; in that case, the transforms from physical
 coordinates to view platform coordinates provided by this class are all
 that are needed.  The <code>ALLOW_LOCAL_TO_VWORLD_READ</code> view platform
 capability doesn't need to be set for these applications.<p>

 <b>Other Synchronization Issues</b><p>
 
 Scene graph updates are guaranteed to take effect in the same frame only
 if run from the processStimulus() method of a Behavior. Updates from
 multiple behaviors are only guaranteed to take effect in the same frame if
 they're responding to a WakeupOnElapsedFrames(0) condition.  Use a single
 behavior to perform view dependent updates if possible; otherwise, use
 WakeupOnElapsedFrames(0) and set behavior scheduling intervals to ensure
 that behaviors that need the current view platform transform are run after
 it's set.  Updating scene graph elements from anything other than the
 Behavior thread, such as an external input thread or a renderer callback
 in Canvas3D, will not necessarily be synchronized with rendering.<p>
 
 Direct updates to geometry data have a different frame latency than
 updates to scene graph transforms and structure. In the Java 3D 1.3
 architecture, updates to by-reference geometry arrays and texture data have
 a 1-frame latency, while updates to transforms and scene graph structure
 have a 2-frame latency.  Because of bug 4799494, which is outstanding
 in Java 3D 1.3.1, updates to by-copy geometry arrays also have a 1-frame
 latency.  It is therefore recommended that view dependent scene graph
 updates be limited to transforms and scene graph structure only.<p>

 If it is not possible to avoid updating geometry directly, then these
 updates must be delayed by one frame in order to remain synchronized with
 the view platform.  This can be accomplished by creating an additional
 behavior to actually update the geometry, separate from the behavior that
 computes the changes that need to be made based on current view state.  If
 the update behavior is awakened by a behavior post from the computing
 behavior then the update will be delayed by a single frame.<p>
 
 <b>Implementation Notes</b><p>
 
 This utility is essentially a rewrite of a few private Java 3D core
 classes, but designed for public use and source code availability.  The
 source code may be helpful in understanding some of the more complex
 aspects of the view model, especially with regards to various interactions
 between attributes which are not adequately documented.  None of the actual
 core Java 3D source code is used, but the code is designed to comply with
 the view model as defined by the Java 3D Specification, so it can be
 considered an alternative implementation.  This class will produce the
 same results as the Java 3D core implementation except for:<p><ul>
 
 <li>The frame latency issue for virtual world transforms.</li><p>
 
 <li>Active clip node status.    If a clip node is active in the scene graph,
     it should override the view's back clip plane.  This class has no such
     information, so this can't be implemented.</li><p>
 
 <li>"Infinite" view transforms for background geometry.  These are simply
     the rotation components of the normal view transforms with adjusted
     clip planes. Again, this function depends upon scene graph content
     inaccessible to this class.</li><p>
 
 <li>Small floating point precision differences resulting from the
     alternative computations.</li><p>
 
 <li>Bugs in this class and the Java 3D core.</li><p>
 
 <li>Tracked head position.</li></ul><p>
 
 The last item deserves some mention.    Java 3D provides no way to directly
 query the tracked head position being used by the renderer.    The View's
 <code>getUserHeadToVworld</code> method always incorporates a virtual world
 transform that is out of date with respect to the application scene graph
 state.  ViewInfo reads data from the head tracking sensor directly, but
 since head trackers are continuous input devices, getting the same data
 that the renderer is using is unlikely.  See the source code for the
 private method <code>getHeadInfo</code> in this class for more information
 and possible workarounds.<p>

 <b>Thread Safety</b><p>
 
 All transforms are lazily evaluated.  The <code>updateScreen</code>,
 <code>updateCanvas</code>, <code>updateViewPlatform</code>,
 <code>updateView</code>, and <code>updateHead</code> methods just set flags
 indicating that derived transforms need to be recomputed; they are safe to
 call from any thread.  <code>updateCanvas</code>, for example, can safely
 be called from an AWT event listener.<p>

 Screens and view platforms can be shared between separate views in the Java
 3D view model.  To remain accurate, ViewInfo also allows this sharing.
 Since it is likely that a multi-view application has separate threads
 managing each view, potential concurrent modification of data associated
 with a screen or a view platform is internally synchronized in this class.
 It is safe for each thread to use its own instance of a ViewInfo
 corresponding to the view it is managing.<p>

 Otherwise, none of the other methods in this class are internally
 synchronized.  <i>Except for the update methods mentioned above, a single
 instance of ViewInfo should not be used by more than one concurrent thread
 without external synchronization.</i><p>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3.1</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#CANVAS_AUTO_UPDATE">CANVAS_AUTO_UPDATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that updates to a Canvas3D associated with the View should
 be automatically checked with each call to a public method in this
 class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#HEAD_AUTO_UPDATE">HEAD_AUTO_UPDATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that updates to the tracked head position should be
 automatically checked with each call to a public method in this class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#PLATFORM_AUTO_UPDATE">PLATFORM_AUTO_UPDATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that updates to the ViewPlatform <code>localToVworld</code>
 transform should be automatically checked with each call to a public
 method in this class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#SCREEN_AUTO_UPDATE">SCREEN_AUTO_UPDATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that updates to a Screen3D associated with the View should
 be automatically checked with each call to a public method in this
 class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#VIEW_AUTO_UPDATE">VIEW_AUTO_UPDATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that updates to the View should be automatically checked
 with each call to a public method in this class.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#ViewInfo(javax.media.j3d.View)">ViewInfo</A></B>(<A HREF="../../../../../javax/media/j3d/View.html" title="class in javax.media.j3d">View</A>&nbsp;view)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new ViewInfo for the specified View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#ViewInfo(javax.media.j3d.View, int)">ViewInfo</A></B>(<A HREF="../../../../../javax/media/j3d/View.html" title="class in javax.media.j3d">View</A>&nbsp;view,
         int&nbsp;autoUpdateFlags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new ViewInfo for the specified View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#ViewInfo(javax.media.j3d.View, int, java.util.Map, java.util.Map)">ViewInfo</A></B>(<A HREF="../../../../../javax/media/j3d/View.html" title="class in javax.media.j3d">View</A>&nbsp;view,
         int&nbsp;autoUpdateFlags,
         java.util.Map&nbsp;screenMap,
         java.util.Map&nbsp;viewPlatformMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new ViewInfo for the specified View.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Release all static memory references held by ViewInfo, if any.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getCoexistenceToImagePlate(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getCoexistenceToImagePlate</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                           <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;coe2ipl,
                           <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;coe2ipr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transforms from coexistence coordinates to image plate
 coordinates and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getCoexistenceToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)">getCoexistenceToViewPlatform</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                             <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;coe2vp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transform from coexistence coordinates to
 view platform coordinates and copies it into the given transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getCoexistenceToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)">getCoexistenceToVworld</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                       <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;coe2vw)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transform from coexistence coordinates to virtual
 world coordinates and copies it into the given transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getEyeToImagePlate(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getEyeToImagePlate</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                   <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2ipl,
                   <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2ipr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the transforms from eye coordinates to image plate coordinates and
 copies them into the Transform3Ds specified.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getEyeToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getEyeToViewPlatform</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                     <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2vpl,
                     <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2vpr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transforms from eye coordinates to view platform
 coordinates and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getEyeToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getEyeToVworld</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
               <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2vwl,
               <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2vwr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transforms from eye coordinates to virtual world
 coordinates and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getHeadTrackerToTrackerBase()">getHeadTrackerToTrackerBase</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to a Transform3D containing the current transform
 from head tracker coordinates to tracker base coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getImagePlateToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getImagePlateToViewPlatform</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                            <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;ip2vpl,
                            <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;ip2vpr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transforms from image plate coordinates to view
 platform coordinates and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getImagePlateToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getImagePlateToVworld</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                      <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;ip2vwl,
                      <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;ip2vwr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transforms from image plate coordinates to virtual
 world coordinates and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getInverseProjection(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getInverseProjection</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                     <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2el,
                     <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2er)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the transforms from clipping coordinates to eye coordinates
 and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getInverseViewPlatformProjection(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getInverseViewPlatformProjection</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                 <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2vpl,
                                 <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2vpr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the transforms from clipping coordinates to view platform
 coordinates and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getInverseVworldProjection(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getInverseVworldProjection</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                           <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2vwl,
                           <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2vwr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the transforms from clipping coordinates to virtual world
 coordinates and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPhysicalBackClipDistance(javax.media.j3d.Canvas3D)">getPhysicalBackClipDistance</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the back clip distance scaled to physical meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPhysicalFrontClipDistance(javax.media.j3d.Canvas3D)">getPhysicalFrontClipDistance</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the front clip distance scaled to physical meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPhysicalHeight(javax.media.j3d.Canvas3D)">getPhysicalHeight</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the height of the specified canvas scaled to physical meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPhysicalLocation(javax.media.j3d.Canvas3D, javax.vecmath.Point3d)">getPhysicalLocation</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                    <A HREF="../../../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;location)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the location of the specified canvas relative to the image plate
 origin.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPhysicalToViewPlatformScale(javax.media.j3d.Canvas3D)">getPhysicalToViewPlatformScale</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the scale factor from physical meters to view platform units.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPhysicalToVirtualScale(javax.media.j3d.Canvas3D)">getPhysicalToVirtualScale</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the scale factor from physical meters to virtual units.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPhysicalWidth(javax.media.j3d.Canvas3D)">getPhysicalWidth</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the width of the specified canvas scaled to physical meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPixelLocationInImagePlate(javax.media.j3d.Canvas3D, int, int, javax.vecmath.Point3d)">getPixelLocationInImagePlate</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                             int&nbsp;x,
                             int&nbsp;y,
                             <A HREF="../../../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;location)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the location of the AWT pixel value and copies it into the
 specified Point3d.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getProjection(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getProjection</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
              <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2ccl,
              <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2ccr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the transforms from eye coordinates to clipping coordinates
 and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getSensorToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Sensor, javax.media.j3d.Transform3D)">getSensorToVworld</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                  <A HREF="../../../../../javax/media/j3d/Sensor.html" title="class in javax.media.j3d">Sensor</A>&nbsp;sensor,
                  <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;s2vw)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a read from the specified sensor and transforms it to virtual
 world coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getTrackerBaseToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)">getTrackerBaseToViewPlatform</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                             <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;tb2vp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the transform from tracker base coordinates to view platform
 coordinates and copies it into the specified Transform3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getTrackerBaseToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)">getTrackerBaseToVworld</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                       <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;tb2vw)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the transform from tracker base coordinates to virtual world
 coordinates and copies it into the specified Transform3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getViewPlatformToCoexistence(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)">getViewPlatformToCoexistence</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                             <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vp2coe)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transform from view platform coordinates to
 coexistence coordinates and copies it into the given transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getViewPlatformToEye(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getViewPlatformToEye</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                     <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vp2el,
                     <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vp2er)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current transforms from view platform coordinates to eye
 coordinates and copies them into the given Transform3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateCanvas(javax.media.j3d.Canvas3D)">updateCanvas</A></B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrange for an update of cached canvas parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateHead()">updateHead</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrange for an update of the cached head position if head tracking is
 enabled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateScreen(javax.media.j3d.Screen3D)">updateScreen</A></B>(<A HREF="../../../../../javax/media/j3d/Screen3D.html" title="class in javax.media.j3d">Screen3D</A>&nbsp;s3d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrange for an update of cached screen parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateView()">updateView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrange for an update of cached view parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateViewPlatform()">updateViewPlatform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrange for an update of the cached <code>localToVworld</code>
 transform of the view platform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#useHeadTracking()">useHeadTracking</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if head tracking should be used.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SCREEN_AUTO_UPDATE"><!-- --></A><H3>
SCREEN_AUTO_UPDATE</H3>
<PRE>
public static final int <B>SCREEN_AUTO_UPDATE</B></PRE>
<DL>
<DD>Indicates that updates to a Screen3D associated with the View should
 be automatically checked with each call to a public method in this
 class.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#com.sun.j3d.utils.universe.ViewInfo.SCREEN_AUTO_UPDATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CANVAS_AUTO_UPDATE"><!-- --></A><H3>
CANVAS_AUTO_UPDATE</H3>
<PRE>
public static final int <B>CANVAS_AUTO_UPDATE</B></PRE>
<DL>
<DD>Indicates that updates to a Canvas3D associated with the View should
 be automatically checked with each call to a public method in this
 class.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#com.sun.j3d.utils.universe.ViewInfo.CANVAS_AUTO_UPDATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VIEW_AUTO_UPDATE"><!-- --></A><H3>
VIEW_AUTO_UPDATE</H3>
<PRE>
public static final int <B>VIEW_AUTO_UPDATE</B></PRE>
<DL>
<DD>Indicates that updates to the View should be automatically checked
 with each call to a public method in this class.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#com.sun.j3d.utils.universe.ViewInfo.VIEW_AUTO_UPDATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="HEAD_AUTO_UPDATE"><!-- --></A><H3>
HEAD_AUTO_UPDATE</H3>
<PRE>
public static final int <B>HEAD_AUTO_UPDATE</B></PRE>
<DL>
<DD>Indicates that updates to the tracked head position should be
 automatically checked with each call to a public method in this class.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#com.sun.j3d.utils.universe.ViewInfo.HEAD_AUTO_UPDATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PLATFORM_AUTO_UPDATE"><!-- --></A><H3>
PLATFORM_AUTO_UPDATE</H3>
<PRE>
public static final int <B>PLATFORM_AUTO_UPDATE</B></PRE>
<DL>
<DD>Indicates that updates to the ViewPlatform <code>localToVworld</code>
 transform should be automatically checked with each call to a public
 method in this class.  The View must be attached to a ViewPlatform
 which is part of a live scene graph, and the ViewPlatform node must
 have its <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#com.sun.j3d.utils.universe.ViewInfo.PLATFORM_AUTO_UPDATE">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ViewInfo(javax.media.j3d.View)"><!-- --></A><H3>
ViewInfo</H3>
<PRE>
public <B>ViewInfo</B>(<A HREF="../../../../../javax/media/j3d/View.html" title="class in javax.media.j3d">View</A>&nbsp;view)</PRE>
<DL>
<DD>Creates a new ViewInfo for the specified View.<p>

 Applications are responsible for informing this class of changes to the
 View, its Canvas3D and Screen3D components, the tracked head position,
 and the ViewPlatform's <code>localToVworld</code> transform.  These
 notifications are performed with the <code>updateView</code>,
 <code>updateCanvas</code>, <code>updateScreen</code>,
 <code>updateHead</code>, and <code>updateViewPlatform</code>
 methods.<p>

 The View must be attached to a ViewPlatform.  If the ViewPlatform is
 attached to a live scene graph, then <code>ALLOW_POLICY_READ</code>
 capability must be set on the ViewPlatform node.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>view</CODE> - the View to use<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateView"><CODE>updateView</CODE></A>, 
<A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateCanvas(javax.media.j3d.Canvas3D)"><CODE>updateCanvas(Canvas3D)</CODE></A>, 
<A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateScreen(javax.media.j3d.Screen3D)"><CODE>updateScreen(Screen3D)</CODE></A>, 
<A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateHead"><CODE>updateHead</CODE></A>, 
<A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateViewPlatform()"><CODE>updateViewPlatform()</CODE></A></DL>
</DL>
<HR>

<A NAME="ViewInfo(javax.media.j3d.View, int)"><!-- --></A><H3>
ViewInfo</H3>
<PRE>
public <B>ViewInfo</B>(<A HREF="../../../../../javax/media/j3d/View.html" title="class in javax.media.j3d">View</A>&nbsp;view,
                int&nbsp;autoUpdateFlags)</PRE>
<DL>
<DD>Creates a new ViewInfo for the specified View.  The View must be
 attached to a ViewPlatform.  If the ViewPlatform is attached to a live
 scene graph, then <code>ALLOW_POLICY_READ</code> capability must be set
 on the ViewPlatform node.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>view</CODE> - the View to use<p><DD><CODE>autoUpdateFlags</CODE> - a logical <code>OR</code> of any of the
        <code>VIEW_AUTO_UPDATE</code>, <code>CANVAS_AUTO_UPDATE</code>,
        <code>SCREEN_AUTO_UPDATE</code>, <code>HEAD_AUTO_UPDATE</code>, or
        <code>PLATFORM_AUTO_UPDATE</code> flags to control whether changes to
        the View, its Canvas3D or Screen3D components, the tracked head
        position, or the ViewPlatform's <code>localToVworld</code> transform
        are checked automatically with each call to a public method of this
        class; if a flag is not set, then the application must inform this
        class of updates to the corresponding data</DL>
</DL>
<HR>

<A NAME="ViewInfo(javax.media.j3d.View, int, java.util.Map, java.util.Map)"><!-- --></A><H3>
ViewInfo</H3>
<PRE>
public <B>ViewInfo</B>(<A HREF="../../../../../javax/media/j3d/View.html" title="class in javax.media.j3d">View</A>&nbsp;view,
                int&nbsp;autoUpdateFlags,
                java.util.Map&nbsp;screenMap,
                java.util.Map&nbsp;viewPlatformMap)</PRE>
<DL>
<DD>Creates a new ViewInfo for the specified View.  The View must be
 attached to a ViewPlatform.  If the ViewPlatform is attached to a live
 scene graph, then <code>ALLOW_POLICY_READ</code> capability must be set
 on the ViewPlatform node.<p>

 ViewInfo caches Screen3D and ViewPlatform data, but Screen3D and
 ViewPlatform instances are shared across multiple Views in the Java 3D
 view model.  Since ViewInfo is per-View, all ViewInfo constructors
 except for this one use static references to manage the shared Screen3D
 and ViewPlatform objects.  In this constructor, however, the caller
 supplies two Map instances to hold these references for all ViewInfo
 instances, so static references can be avoided; it can be used to wrap
 this class into a multi-view context that provides the required
 maps.<p>

 Alternatively, the other constructors can be used by calling
 <code>ViewInfo.clear</code> when done with ViewInfo, or by simply
 retaining the static references until the JVM exits.<p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>view</CODE> - the View to use<p><DD><CODE>autoUpdateFlags</CODE> - a logical <code>OR</code> of any of the
        <code>VIEW_AUTO_UPDATE</code>, <code>CANVAS_AUTO_UPDATE</code>,
        <code>SCREEN_AUTO_UPDATE</code>, <code>HEAD_AUTO_UPDATE</code>, or
        <code>PLATFORM_AUTO_UPDATE</code> flags to control whether changes to
        the View, its Canvas3D or Screen3D components, the tracked head
        position, or the ViewPlatform's <code>localToVworld</code> transform
        are checked automatically with each call to a public method of this
        class; if a flag is not set, then the application must inform this
        class of updates to the corresponding data<p><DD><CODE>screenMap</CODE> - a writeable Map to hold Screen3D information<DD><CODE>viewPlatformMap</CODE> - a writeable Map to hold ViewPlatform information</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getImagePlateToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getImagePlateToViewPlatform</H3>
<PRE>
public void <B>getImagePlateToViewPlatform</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                        <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;ip2vpl,
                                        <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;ip2vpr)</PRE>
<DL>
<DD>Gets the current transforms from image plate coordinates to view
 platform coordinates and copies them into the given Transform3Ds.<p>
 
 With a monoscopic canvas the image plate transform is copied to the
 first argument and the second argument is not used.  For a stereo
 canvas the first argument receives the left image plate transform, and
 if the second argument is non-null it receives the right image plate
 transform.  These transforms are always the same unless a head mounted
 display driven by a single stereo canvas is in use.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D associated with the image plate<DD><CODE>ip2vpl</CODE> - the Transform3D to receive the left transform<DD><CODE>ip2vpr</CODE> - the Transform3D to receive the right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getImagePlateToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getImagePlateToVworld</H3>
<PRE>
public void <B>getImagePlateToVworld</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                  <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;ip2vwl,
                                  <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;ip2vwr)</PRE>
<DL>
<DD>Gets the current transforms from image plate coordinates to virtual
 world coordinates and copies them into the given Transform3Ds.<p>
 
 With a monoscopic canvas the image plate transform is copied to the
 first argument and the second argument is not used.  For a stereo
 canvas the first argument receives the left image plate transform, and
 if the second argument is non-null it receives the right image plate
 transform.  These transforms are always the same unless a head mounted
 display driven by a single stereo canvas is in use.<p>

 The View must be attached to a ViewPlatform which is part of a live
 scene graph, and the ViewPlatform node must have its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D associated with the image plate<DD><CODE>ip2vwl</CODE> - the Transform3D to receive the left transform<DD><CODE>ip2vwr</CODE> - the Transform3D to receive the right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getCoexistenceToImagePlate(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getCoexistenceToImagePlate</H3>
<PRE>
public void <B>getCoexistenceToImagePlate</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                       <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;coe2ipl,
                                       <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;coe2ipr)</PRE>
<DL>
<DD>Gets the current transforms from coexistence coordinates to image plate
 coordinates and copies them into the given Transform3Ds.  The default
 coexistence centering enable and window movement policies are
 <code>true</code> and <code>PHYSICAL_WORLD</code> respectively, which
 will center coexistence coordinates to the middle of the canvas,
 aligned with the screen (image plate). A movement policy of
 <code>VIRTUAL_WORLD</code> centers coexistence coordinates to the
 middle of the screen.<p>

 If coexistence centering is turned off, then canvases and screens can
 have arbitrary positions with respect to coexistence, set through the
 the Screen3D <code>trackerBaseToImagePlate</code> transform and the
 PhysicalEnvironment <code>coexistenceToTrackerBase</code> transform.
 These are calibration constants used for multiple fixed screen displays.
 For head mounted displays the transform is determined by the user head
 position along with calibration parameters found in Screen3D and
 PhysicalBody. (See the source code for the private method
 <code>getEyesHMD</code> for more information).<p>

 With a monoscopic canvas the image plate transform is copied to the
 first argument and the second argument is not used.  For a stereo
 canvas the first argument receives the left image plate transform, and
 if the second argument is non-null it receives the right image plate
 transform.  These transforms are always the same unless a head mounted
 display driven by a single stereo canvas is in use.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D associated with the image plate<DD><CODE>coe2ipl</CODE> - the Transform3D to receive the left transform<DD><CODE>coe2ipr</CODE> - the Transform3D to receive the right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getViewPlatformToCoexistence(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getViewPlatformToCoexistence</H3>
<PRE>
public void <B>getViewPlatformToCoexistence</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                         <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vp2coe)</PRE>
<DL>
<DD>Gets the current transform from view platform coordinates to
 coexistence coordinates and copies it into the given transform.        View
 platform coordinates are always aligned with coexistence coordinates
 but may differ in scale and in Y and Z offset.  The scale is derived
 from the window resize and screen scale policies, while the offset is
 derived from the view attach policy.<p>

 Java 3D constructs a view from the physical position of the eyes
 relative to the physical positions of the image plates; it then uses a
 view platform to position that physical configuration into the virtual
 world and from there computes the correct projections of the virtual
 world onto the physical image plates.  Coexistence coordinates are used
 to place the physical positions of the view platform, eyes, head, image
 plate, sensors, and tracker base in relation to each other. The view
 platform is positioned with respect to the virtual world through the
 scene graph, so the view platform to coexistence transform defines the
 space in which the virtual world and physical world coexist.<p>
 
 This method requires a Canvas3D.        A different transform may be returned
 for each canvas in the view if any of the following apply:<p><ul>

 <li>The window resize policy is <code>PHYSICAL_WORLD</code>, which
           alters the scale depending upon the width of the canvas.</li><p>

 <li>The screen scale policy is <code>SCALE_SCREEN_SIZE</code>,
           which alters the scale depending upon the width of the screen
           associated with the canvas.</li><p>

 <li>A window eyepoint policy of <code>RELATIVE_TO_FIELD_OF_VIEW</code>
           with a view attach policy of <code>NOMINAL_HEAD</code> in effect,
           which sets the view platform Z offset in coexistence coordinates
           based on the width of the canvas.  These are the default policies.
           The offset also follows the width of the canvas when the
           <code>NOMINAL_FEET</code> view attach policy is used.</li></ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>vp2coe</CODE> - the Transform3D to receive the transform</DL>
</DD>
</DL>
<HR>

<A NAME="getCoexistenceToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getCoexistenceToViewPlatform</H3>
<PRE>
public void <B>getCoexistenceToViewPlatform</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                         <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;coe2vp)</PRE>
<DL>
<DD>Gets the current transform from coexistence coordinates to
 view platform coordinates and copies it into the given transform.<p>

 This method requires a Canvas3D.        The returned transform may differ
 across canvases for the same reasons as discussed in the description of
 <code>getViewPlatformToCoexistence</code>.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>coe2vp</CODE> - the Transform3D to receive the transform<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getViewPlatformToCoexistence(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><CODE>getViewPlatformToCoexistence(Canvas3D, Transform3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCoexistenceToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getCoexistenceToVworld</H3>
<PRE>
public void <B>getCoexistenceToVworld</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                   <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;coe2vw)</PRE>
<DL>
<DD>Gets the current transform from coexistence coordinates to virtual
 world coordinates and copies it into the given transform.<p>

 The View must be attached to a ViewPlatform which is part of a live
 scene graph, and the ViewPlatform node must have its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.<p>

 This method requires a Canvas3D.        The returned transform may differ
 across canvases for the same reasons as discussed in the description of
 <code>getViewPlatformToCoexistence</code>.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>coe2vw</CODE> - the Transform3D to receive the transform<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getViewPlatformToCoexistence(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><CODE>getViewPlatformToCoexistence(Canvas3D, Transform3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getEyeToImagePlate(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getEyeToImagePlate</H3>
<PRE>
public void <B>getEyeToImagePlate</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                               <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2ipl,
                               <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2ipr)</PRE>
<DL>
<DD>Gets the transforms from eye coordinates to image plate coordinates and
 copies them into the Transform3Ds specified.<p>
 
 When head tracking is used the eye positions are taken from the head
 position and set in relation to the image plates with each Screen3D's
 <code>trackerBaseToImagePlate</code> transform.        Otherwise the window
 eyepoint policy is used to derive the eyepoint relative to the image
 plate.  When using a head mounted display the eye position is
 determined solely by calibration constants in Screen3D and
 PhysicalBody; see the source code for the private method
 <code>getEyesHMD</code> for more information.<p>
 
 Eye coordinates are always aligned with image plate coordinates, so
 these transforms are always just translations.  With a monoscopic
 canvas the eye transform is copied to the first argument and the second
 argument is not used.  For a stereo canvas the first argument receives
 the left eye transform, and if the second argument is non-null it
 receives the right eye transform.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D associated with the image plate<DD><CODE>e2ipl</CODE> - the Transform3D to receive left transform<DD><CODE>e2ipr</CODE> - the Transform3D to receive right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getEyeToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getEyeToViewPlatform</H3>
<PRE>
public void <B>getEyeToViewPlatform</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                 <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2vpl,
                                 <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2vpr)</PRE>
<DL>
<DD>Gets the current transforms from eye coordinates to view platform
 coordinates and copies them into the given Transform3Ds.<p>
 
 With a monoscopic canvas the eye transform is copied to the first
 argument and the second argument is not used.  For a stereo canvas the
 first argument receives the left eye transform, and if the second
 argument is non-null it receives the right eye transform.<p>

 This method requires a Canvas3D.        When using a head mounted display,
 head tracking with fixed screens, or a window eyepoint policy of
 <code>RELATIVE_TO_COEXISTENCE</code>, then the transforms returned may
 be different for each canvas if stereo is not in use and they have
 different monoscopic view policies.  They may additionally differ in
 scale across canvases with the <code>PHYSICAL_WORLD</code> window
 resize policy or the <code>SCALE_SCREEN_SIZE</code> screen scale
 policy, which alter the scale depending upon the width of the canvas or
 the width of the screen respectively.<p>
 
 With window eyepoint policies of <code>RELATIVE_TO_FIELD_OF_VIEW</code>,
 <code>RELATIVE_TO_SCREEN</code>, or <code>RELATIVE_TO_WINDOW</code>,
 then the transforms returned may differ across canvases due to
 the following additional conditions:<p><ul>
 
 <li>The window eyepoint policy is <code>RELATIVE_TO_WINDOW</code> or
           <code>RELATIVE_TO_SCREEN</code>, in which case the manual eye
           position in image plate can be set differently for each
           canvas.</li><p>

 <li>The window eyepoint policy is <code>RELATIVE_TO_FIELD_OF_VIEW</code>
           and the view attach policy is <code>NOMINAL_SCREEN</code>, which
           decouples the view platform's canvas Z offset from the eyepoint's
           canvas Z offset.</li><p> 

 <li>The eyepoint X and Y coordinates are centered in the canvas with a
           window eyepoint policy of <code>RELATIVE_TO_FIELD_OF_VIEW</code>
           or <code>RELATIVE_TO_WINDOW</code>, and a window movement policy
           of <code>VIRTUAL_WORLD</code> centers the view platform's X and Y
           coordinates to the middle of the screen.</li><p>

 <li>Coexistence centering is set false, which allows each canvas and
           screen to have a different position with respect to coexistence
           coordinates.</li></ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>e2vpl</CODE> - the Transform3D to receive the left transform<DD><CODE>e2vpr</CODE> - the Transform3D to receive the right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getViewPlatformToEye(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getViewPlatformToEye</H3>
<PRE>
public void <B>getViewPlatformToEye</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                 <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vp2el,
                                 <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vp2er)</PRE>
<DL>
<DD>Gets the current transforms from view platform coordinates to eye
 coordinates and copies them into the given Transform3Ds.<p>
 
 With a monoscopic canvas the eye transform is copied to the first
 argument and the second argument is not used.  For a stereo canvas the
 first argument receives the left eye transform, and if the second
 argument is non-null it receives the right eye transform.<p>

 This method requires a Canvas3D.        The transforms returned may differ
 across canvases for all the same reasons discussed in the description
 of <code>getEyeToViewPlatform</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>vp2el</CODE> - the Transform3D to receive the left transform<DD><CODE>vp2er</CODE> - the Transform3D to receive the right transform, or null<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getEyeToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><CODE>getEyeToViewPlatform(Canvas3D, Transform3D, Transform3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getEyeToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getEyeToVworld</H3>
<PRE>
public void <B>getEyeToVworld</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                           <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2vwl,
                           <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2vwr)</PRE>
<DL>
<DD>Gets the current transforms from eye coordinates to virtual world
 coordinates and copies them into the given Transform3Ds.<p>
 
 With a monoscopic canvas the eye transform is copied to the first
 argument and the second argument is not used.  For a stereo canvas the
 first argument receives the left eye transform, and if the second
 argument is non-null it receives the right eye transform.<p>

 The View must be attached to a ViewPlatform which is part of a live
 scene graph, and the ViewPlatform node must have its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.<p>

 This method requires a Canvas3D.        The transforms returned may differ
 across canvases for all the same reasons discussed in the description
 of <code>getEyeToViewPlatform</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>e2vwl</CODE> - the Transform3D to receive the left transform<DD><CODE>e2vwr</CODE> - the Transform3D to receive the right transform, or null<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getEyeToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><CODE>getEyeToViewPlatform(Canvas3D, Transform3D, Transform3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getProjection(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getProjection</H3>
<PRE>
public void <B>getProjection</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                          <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2ccl,
                          <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;e2ccr)</PRE>
<DL>
<DD>Gets the transforms from eye coordinates to clipping coordinates
 and copies them into the given Transform3Ds.  These transforms take
 a viewing volume bounded by the physical canvas edges and the
 physical front and back clip planes and project it into a range
 bound to [-1.0 .. +1.0] on each of the X, Y, and Z axes.        If a
 perspective projection has been specified then the physical image
 plate eye location defines the apex of a viewing frustum;
 otherwise, the orientation of the image plate determines the
 direction of a parallel projection.<p>
 
 With a monoscopic canvas the projection transform is copied to the
 first argument and the second argument is not used.  For a stereo
 canvas the first argument receives the left projection transform,
 and if the second argument is non-null it receives the right
 projection transform.<p>

 If either of the clip policies <code>VIRTUAL_EYE</code> or
 <code>VIRTUAL_SCREEN</code> are used, then the View should be attached
 to a ViewPlatform that is part of a live scene graph and that has its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set; otherwise, a
 scale factor of 1.0 will be used for the scale factor from virtual
 world units to view platform units.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>e2ccl</CODE> - the Transform3D to receive left transform<DD><CODE>e2ccr</CODE> - the Transform3D to receive right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getInverseProjection(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getInverseProjection</H3>
<PRE>
public void <B>getInverseProjection</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                 <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2el,
                                 <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2er)</PRE>
<DL>
<DD>Gets the transforms from clipping coordinates to eye coordinates
 and copies them into the given Transform3Ds.  These transforms take
 the clip space volume bounded by the range [-1.0 .. + 1.0] on each
 of the X, Y, and Z and project it into eye coordinates.<p>
 
 With a monoscopic canvas the projection transform is copied to the
 first argument and the second argument is not used.  For a stereo
 canvas the first argument receives the left projection transform, and
 if the second argument is non-null it receives the right projection
 transform.<p>

 If either of the clip policies <code>VIRTUAL_EYE</code> or
 <code>VIRTUAL_SCREEN</code> are used, then the View should be attached
 to a ViewPlatform that is part of a live scene graph and that has its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set; otherwise, a
 scale factor of 1.0 will be used for the scale factor from virtual
 world units to view platform units.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>cc2el</CODE> - the Transform3D to receive left transform<DD><CODE>cc2er</CODE> - the Transform3D to receive right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getInverseViewPlatformProjection(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getInverseViewPlatformProjection</H3>
<PRE>
public void <B>getInverseViewPlatformProjection</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                             <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2vpl,
                                             <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2vpr)</PRE>
<DL>
<DD>Gets the transforms from clipping coordinates to view platform
 coordinates and copies them into the given Transform3Ds.        These
 transforms take the clip space volume bounded by the range
 [-1.0 .. +1.0] on each of the X, Y, and Z axes and project into
 the view platform coordinate system.<p>
 
 With a monoscopic canvas the projection transform is copied to the
 first argument and the second argument is not used.  For a stereo
 canvas the first argument receives the left projection transform, and
 if the second argument is non-null it receives the right projection
 transform.<p>

 If either of the clip policies <code>VIRTUAL_EYE</code> or
 <code>VIRTUAL_SCREEN</code> are used, then the View should be attached
 to a ViewPlatform that is part of a live scene graph and that has its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set; otherwise, a
 scale factor of 1.0 will be used for the scale factor from virtual
 world units to view platform units.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>cc2vpl</CODE> - the Transform3D to receive left transform<DD><CODE>cc2vpr</CODE> - the Transform3D to receive right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getInverseVworldProjection(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getInverseVworldProjection</H3>
<PRE>
public void <B>getInverseVworldProjection</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                       <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2vwl,
                                       <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;cc2vwr)</PRE>
<DL>
<DD>Gets the transforms from clipping coordinates to virtual world
 coordinates and copies them into the given Transform3Ds.        These
 transforms take the clip space volume bounded by the range
 [-1.0 .. +1.0] on each of the X, Y, and Z axes and project into
 the virtual world.<p>
 
 With a monoscopic canvas the projection transform is copied to the
 first argument and the second argument is not used.  For a stereo
 canvas the first argument receives the left projection transform, and
 if the second argument is non-null it receives the right projection
 transform.<p>

 The View must be attached to a ViewPlatform which is part of a live
 scene graph, and the ViewPlatform node must have its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>cc2vwl</CODE> - the Transform3D to receive left transform<DD><CODE>cc2vwr</CODE> - the Transform3D to receive right transform, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalFrontClipDistance(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
getPhysicalFrontClipDistance</H3>
<PRE>
public double <B>getPhysicalFrontClipDistance</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</PRE>
<DL>
<DD>Gets the front clip distance scaled to physical meters.  This is useful
 for ensuring that objects positioned relative to a physical coordinate
 system (such as eye, image plate, or coexistence) will be within the
 viewable Z depth.  This distance will be relative to either the eye or
 the image plate depending upon the front clip policy.<p>

 Note that this is not necessarily the clip distance as set by
 <code>setFrontClipDistance</code>, even when the front clip policy
 is <code>PHYSICAL_SCREEN</code> or <code>PHYSICAL_EYE</code>.  <i>If
 the window resize policy is <code>PHYSICAL_WORLD</code>, then physical
 clip distances as specified are in fact scaled by the ratio of the
 window width to the screen width.</i> The Java 3D view model does this
 to prevent the physical clip planes from moving with respect to the
 virtual world when the window is resized.<p>

 If either of the clip policies <code>VIRTUAL_EYE</code> or
 <code>VIRTUAL_SCREEN</code> are used, then the View should be attached
 to a ViewPlatform that is part of a live scene graph and that has its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set; otherwise, a
 scale factor of 1.0 will be used for the scale factor from virtual
 world units to view platform units.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use
<DT><B>Returns:</B><DD>the physical front clip distance</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalBackClipDistance(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
getPhysicalBackClipDistance</H3>
<PRE>
public double <B>getPhysicalBackClipDistance</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</PRE>
<DL>
<DD>Gets the back clip distance scaled to physical meters.  This is useful
 for ensuring that objects positioned relative to a physical coordinate
 system (such as eye, image plate, or coexistence) will be within the
 viewable Z depth.  This distance will be relative to either the eye or
 the image plate depending upon the back clip policy.<p>

 Note that this is not necessarily the clip distance as set by
 <code>setBackClipDistance</code>, even when the back clip policy
 is <code>PHYSICAL_SCREEN</code> or <code>PHYSICAL_EYE</code>.  <i>If
 the window resize policy is <code>PHYSICAL_WORLD</code>, then physical
 clip distances as specified are in fact scaled by the ratio of the
 window width to the screen width.</i> The Java 3D view model does this
 to prevent the physical clip planes from moving with respect to the
 virtual world when the window is resized.<p>

 If either of the clip policies <code>VIRTUAL_EYE</code> or
 <code>VIRTUAL_SCREEN</code> are used, then the View should be attached
 to a ViewPlatform that is part of a live scene graph and that has its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set; otherwise, a
 scale factor of 1.0 will be used for the scale factor from virtual
 world units to view platform units.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use
<DT><B>Returns:</B><DD>the physical back clip distance</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalToViewPlatformScale(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
getPhysicalToViewPlatformScale</H3>
<PRE>
public double <B>getPhysicalToViewPlatformScale</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</PRE>
<DL>
<DD>Gets the scale factor from physical meters to view platform units.<p>
 
 This method requires a Canvas3D.        A different scale may be returned
 for each canvas in the view if any of the following apply:<p><ul>

 <li>The window resize policy is <code>PHYSICAL_WORLD</code>, which
           alters the scale depending upon the width of the canvas.</li><p>

 <li>The screen scale policy is <code>SCALE_SCREEN_SIZE</code>,
           which alters the scale depending upon the width of the screen
           associated with the canvas.</li></ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use
<DT><B>Returns:</B><DD>the physical to view platform scale</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalToVirtualScale(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
getPhysicalToVirtualScale</H3>
<PRE>
public double <B>getPhysicalToVirtualScale</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</PRE>
<DL>
<DD>Gets the scale factor from physical meters to virtual units.<p>
 
 This method requires a Canvas3D.        A different scale may be returned
 across canvases for the same reasons as discussed in the description of
 <code>getPhysicalToViewPlatformScale</code>.<p>

 The View must be attached to a ViewPlatform which is part of a live
 scene graph, and the ViewPlatform node must have its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use
<DT><B>Returns:</B><DD>the physical to virtual scale<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getPhysicalToViewPlatformScale(javax.media.j3d.Canvas3D)"><CODE>getPhysicalToViewPlatformScale(Canvas3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalWidth(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
getPhysicalWidth</H3>
<PRE>
public double <B>getPhysicalWidth</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</PRE>
<DL>
<DD>Gets the width of the specified canvas scaled to physical meters.  This
 is derived from the physical screen width as reported by the Screen3D
 associated with the canvas.  If the screen width is not explicitly set
 using the <code>setPhysicalScreenWidth</code> method of Screen3D, then
 Java 3D will derive the screen width based on a screen resolution of 90
 pixels/inch.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use
<DT><B>Returns:</B><DD>the width of the canvas scaled to physical meters</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalHeight(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
getPhysicalHeight</H3>
<PRE>
public double <B>getPhysicalHeight</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</PRE>
<DL>
<DD>Gets the height of the specified canvas scaled to physical meters.  This
 is derived from the physical screen height as reported by the Screen3D
 associated with the canvas.  If the screen height is not explicitly set
 using the <code>setPhysicalScreenHeight</code> method of Screen3D, then
 Java 3D will derive the screen height based on a screen resolution of 90
 pixels/inch.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use
<DT><B>Returns:</B><DD>the height of the canvas scaled to physical meters</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalLocation(javax.media.j3d.Canvas3D, javax.vecmath.Point3d)"><!-- --></A><H3>
getPhysicalLocation</H3>
<PRE>
public void <B>getPhysicalLocation</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                <A HREF="../../../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;location)</PRE>
<DL>
<DD>Gets the location of the specified canvas relative to the image plate
 origin.  This is derived from the physical screen parameters as
 reported by the Screen3D associated with the canvas.  If the screen
 width and height are not explicitly set in Screen3D, then Java 3D will
 derive those screen parameters based on a screen resolution of 90
 pixels/inch.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>location</CODE> - the output position, in meters, of the lower-left
  corner of the canvas relative to the image plate lower-left corner; Z
  is always 0.0</DL>
</DD>
</DL>
<HR>

<A NAME="getPixelLocationInImagePlate(javax.media.j3d.Canvas3D, int, int, javax.vecmath.Point3d)"><!-- --></A><H3>
getPixelLocationInImagePlate</H3>
<PRE>
public void <B>getPixelLocationInImagePlate</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                         int&nbsp;x,
                                         int&nbsp;y,
                                         <A HREF="../../../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;location)</PRE>
<DL>
<DD>Gets the location of the AWT pixel value and copies it into the
 specified Point3d.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>x</CODE> - the X coordinate of the pixel relative to the upper-left
  corner of the canvas<DD><CODE>y</CODE> - the Y coordinate of the pixel relative to the upper-left
  corner of the canvas<DD><CODE>location</CODE> - the output position, in meters, relative to the
  lower-left corner of the image plate; Z is always 0.0</DL>
</DD>
</DL>
<HR>

<A NAME="getSensorToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Sensor, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getSensorToVworld</H3>
<PRE>
public void <B>getSensorToVworld</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                              <A HREF="../../../../../javax/media/j3d/Sensor.html" title="class in javax.media.j3d">Sensor</A>&nbsp;sensor,
                              <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;s2vw)</PRE>
<DL>
<DD>Gets a read from the specified sensor and transforms it to virtual
 world coordinates.  The View must be attached to a ViewPlatform which
 is part of a live scene graph, and the ViewPlatform node must have its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.<p>

 This method requires a Canvas3D.        The returned transform may differ
 across canvases for the same reasons as discussed in the description of
 <code>getViewPlatformToCoexistence</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sensor</CODE> - the Sensor instance to read<DD><CODE>s2vw</CODE> - the output transform<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getViewPlatformToCoexistence(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><CODE>getViewPlatformToCoexistence(Canvas3D, Transform3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTrackerBaseToViewPlatform(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getTrackerBaseToViewPlatform</H3>
<PRE>
public void <B>getTrackerBaseToViewPlatform</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                         <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;tb2vp)</PRE>
<DL>
<DD>Gets the transform from tracker base coordinates to view platform
 coordinates and copies it into the specified Transform3D.<p>

 This method requires a Canvas3D.        The returned transform may differ
 across canvases for the same reasons as discussed in the description of
 <code>getViewPlatformToCoexistence</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>tb2vp</CODE> - the output transform<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getViewPlatformToCoexistence(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><CODE>getViewPlatformToCoexistence(Canvas3D, Transform3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTrackerBaseToVworld(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getTrackerBaseToVworld</H3>
<PRE>
public void <B>getTrackerBaseToVworld</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d,
                                   <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;tb2vw)</PRE>
<DL>
<DD>Gets the transform from tracker base coordinates to virtual world
 coordinates and copies it into the specified Transform3D.  The View
 must be attached to a ViewPlatform which is part of a live scene graph,
 and the ViewPlatform node must have its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.<p>

 This method requires a Canvas3D.        The returned transform may differ
 across canvases for the same reasons as discussed in the description of
 <code>getViewPlatformToCoexistence</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to use<DD><CODE>tb2vw</CODE> - the output transform<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#getViewPlatformToCoexistence(javax.media.j3d.Canvas3D, javax.media.j3d.Transform3D)"><CODE>getViewPlatformToCoexistence(Canvas3D, Transform3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public static void <B>clear</B>()</PRE>
<DL>
<DD>Release all static memory references held by ViewInfo, if any.  These
 are the Screen3D and ViewPlatform maps shared by all existing ViewInfo
 instances if they're not provided by a constructor.  Releasing the
 screen references effectively releases all canvas references in all
 ViewInfo instances as well.<p>

 It is safe to continue using existing ViewInfo instances after calling
 this method; the data in the released maps will be re-derived as
 needed.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateScreen(javax.media.j3d.Screen3D)"><!-- --></A><H3>
updateScreen</H3>
<PRE>
public void <B>updateScreen</B>(<A HREF="../../../../../javax/media/j3d/Screen3D.html" title="class in javax.media.j3d">Screen3D</A>&nbsp;s3d)</PRE>
<DL>
<DD>Arrange for an update of cached screen parameters.  If automatic update
 has not been enabled, then this method should be called if any of the
 attributes of the Screen3D have changed.        This method should also be
 called if the screen changes pixel resolution.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s3d</CODE> - the Screen3D to update</DL>
</DD>
</DL>
<HR>

<A NAME="updateCanvas(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
updateCanvas</H3>
<PRE>
public void <B>updateCanvas</B>(<A HREF="../../../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;c3d)</PRE>
<DL>
<DD>Arrange for an update of cached canvas parameters.  If automatic update
 has not been enabled, then this method should be called if any of the
 attributes of the Canvas3D have changed.        These attributes include the
 canvas position and size, but do <i>not</i> include the attributes of
 the associated Screen3D, which are cached separately.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c3d</CODE> - the Canvas3D to update</DL>
</DD>
</DL>
<HR>

<A NAME="updateView()"><!-- --></A><H3>
updateView</H3>
<PRE>
public void <B>updateView</B>()</PRE>
<DL>
<DD>Arrange for an update of cached view parameters.         If automatic update
 has not been enabled for the View, then this method should be called if
 any of the attributes of the View associated with this object have
 changed.<p>
 
 These do <i>not</i> include the attributes of the existing Canvas3D or
 Screen3D components of the View, but do include the attributes of all
 other components such as the PhysicalEnvironment and PhysicalBody, and
 all attributes of the attached ViewPlatform except for its
 <code>localToVworld</code> transform.  The screen and canvas components
 as well as the ViewPlatform's <code>localToVworld</code> are cached
 separately.<p>

 This method should also be called if the ViewPlatform is replaced with
 another using the View's <code>attachViewPlatform</code> method, or if
 any of the <code>setCanvas3D</code>, <code>addCanvas3D</code>,
 <code>insertCanvas3D</code>, <code>removeCanvas3D</code>, or
 <code>removeAllCanvas3Ds</code> methods of View are called to change
 the View's canvas list.<p>

 Calling this method causes most transforms to be re-derived.  It should
 be used only when necessary.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateHead()"><!-- --></A><H3>
updateHead</H3>
<PRE>
public void <B>updateHead</B>()</PRE>
<DL>
<DD>Arrange for an update of the cached head position if head tracking is
 enabled.        If automatic update has not enabled for the head position,
 then this method should be called anytime a new head position is to be
 read.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateViewPlatform()"><!-- --></A><H3>
updateViewPlatform</H3>
<PRE>
public void <B>updateViewPlatform</B>()</PRE>
<DL>
<DD>Arrange for an update of the cached <code>localToVworld</code>
 transform of the view platform.        If automatic update has not been
 enabled for this transform, then this method should be called anytime
 the view platform has been repositioned in the virtual world and a
 transform involving virtual world coordinates is desired.<p>

 The View must be attached to a ViewPlatform which is part of a live
 scene graph, and the ViewPlatform node must have its
 <code>ALLOW_LOCAL_TO_VWORLD_READ</code> capability set.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getHeadTrackerToTrackerBase()"><!-- --></A><H3>
getHeadTrackerToTrackerBase</H3>
<PRE>
protected <A HREF="../../../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A> <B>getHeadTrackerToTrackerBase</B>()</PRE>
<DL>
<DD>Returns a reference to a Transform3D containing the current transform
 from head tracker coordinates to tracker base coordinates.  It is only
 called if <code>useHeadTracking</code> returns true and a head position
 update is specified with <code>updateHead</code> or the
 <code>HEAD_AUTO_UPDATE</code> constructor flag.<p>

 The default implementation uses the head tracking sensor specified by
 the View's PhysicalEnvironment, and reads it by calling the sensor's
 <code>getRead</code> method directly.  The result is a sensor reading
 that may have been taken at a slightly different time from the one used
 by the renderer.  This method can be overridden to synchronize the two
 readings through an external mechanism.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>current head tracker to tracker base transform<DT><B>See Also:</B><DD><A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#useHeadTracking()"><CODE>useHeadTracking()</CODE></A>, 
<A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#updateHead"><CODE>updateHead</CODE></A>, 
<A HREF="../../../../../com/sun/j3d/utils/universe/ViewInfo.html#HEAD_AUTO_UPDATE"><CODE>HEAD_AUTO_UPDATE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="useHeadTracking()"><!-- --></A><H3>
useHeadTracking</H3>
<PRE>
protected boolean <B>useHeadTracking</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if head tracking should be used.<p>

 The default implementation returns <code>true</code> if the View's
 <code>getTrackingEnable</code> method and the PhysicalEnvironment's
 <code>getTrackingAvailable</code> method both return <code>true</code>.
 These are the same conditions under which the Java 3D renderer uses
 head tracking.  This method can be overridden if there is any need to
 decouple the head tracking status of ViewInfo from the renderer.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if ViewInfo should use head tracking</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../com/sun/j3d/utils/universe/ViewerAvatar.html" title="class in com.sun.j3d.utils.universe"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../com/sun/j3d/utils/universe/ViewingPlatform.html" title="class in com.sun.j3d.utils.universe"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?com/sun/j3d/utils/universe/ViewInfo.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ViewInfo.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1">Copyright 1996-2008 Sun Microsystems, Inc. All Rights Reserved. Use is subject to <a href="../../../../../LICENSE-SPEC.html">license terms</a>.
</BODY>
</HTML>
